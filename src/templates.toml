version = 0.1
[[template]]
name = "babel"
definition = """({ name, targets, deps, env, templateOptions: { presets = [], plugins = [], sourceMap = true, noBabelRc = false, configFile = null, autoInstall } }, { CHOMP_EJECT }) => {
  const defaultConfig = {};
  return [{
    name,
    targets,
    deps: [...deps, ...noBabelRc || CHOMP_EJECT ? [] : ['.babelrc'], ...CHOMP_EJECT ? [] : presets.map(p => `node_modules/${p}`), ...plugins.map(p => `node_modules/${p}`), ...CHOMP_EJECT ? [] : ['node_modules/@babel/core', 'node_modules/@babel/cli']],
    env,
    run: `babel $DEP -o $TARGET${
        sourceMap ? ' --source-maps' : ''
      }${
        plugins.length ? ` --plugins=${plugins.join(',')}` : ''
      }${
        presets.length ? ` --presets=${presets.join(',')}` : ''
      }${
        noBabelRc ? ' --no-babelrc' : ''
      }${
        configFile ? ` --config-file=${configFile.startsWith('./') ? configFile : './' + configFile}` : ''
      }`
  }, ...CHOMP_EJECT ? [] : [{
    target: '.babelrc',
    invalidation: 'not-found',
    run: `
      echo '\n\\x1b[93mChomp\\x1b[0m: Creating \\x1b[1m.babelrc\\x1b[0m (set \\x1b[1m"no-babel-rc = true"\\x1b[0m Babel template option to skip)\n'
      echo '${JSON.stringify(defaultConfig, null, 2)}' > .babelrc
    `
  }, {
    template: 'npm',
    templateOptions: {
      packages: [...presets.map(p => p.startsWith('@babel/') ? p + '@7' : p), ...plugins.map(p => p.startsWith('@babel/') ? p + '@7' : p), '@babel/core@7', '@babel/cli@7'],
      dev: true,
      autoInstall
    }
  }]];
}
"""
[[template]]
name = "cargo"
definition = """({ deps, env, templateOptions: { bin, install } }, { PATH, CHOMP_EJECT }) => {
  const sep = PATH.match(/\\\\|\\//)[0];
  return CHOMP_EJECT ? [] : [{
    name: `cargo:${bin}`,
    targets: [PATH.split(';').find(p => p.endsWith(`.cargo${sep}bin`)) + sep + bin + (sep === '/' ? '' : '.exe')],
    invalidation: 'not-found',
    deps,
    env,
    run: `cargo install ${install}`
  }]];
}
"""
[[template]]
name = "jspm"
definition = """({ name, targets, deps, env, templateOptions: {
  autoInstall,
  env: generatorEnv = ['browser', 'production', 'module'],
  preload,
  integrity,
  whitespace,
  esModuleShims,
  ...generateOpts
} }, { CHOMP_EJECT }) => {
  const mainTarget = targets.find(target => target.includes('#')) || targets[0];
  const isImportMapTarget = mainTarget && mainTarget.endsWith('.importmap');
  const { resolutions } = generateOpts;
  const noHtmlOpts = preload === undefined && integrity === undefined && whitespace === undefined && esModuleShims === undefined;
  return [{
    name,
    targets,
    invalidation: 'always',
    deps: [...deps, ...CHOMP_EJECT ? [] : ['node_modules/@jspm/generator', 'node_modules/mkdirp']],
    env,
    engine: 'node',
    run: `    import { Generator } from '@jspm/generator';
    import { readFile, writeFile } from 'fs/promises';
    import { pathToFileURL } from 'url';
    import mkdirp from 'mkdirp';

    const generator = new Generator({
      mapUrl: ${isImportMapTarget ? 'import.meta.url' : 'pathToFileURL(process.env.TARGET)'}${
        resolutions && !isImportMapTarget && Object.values(resolutions).some(v => v.startsWith('./') || v.startsWith('../')) ? ',\\n      baseUrl: import.meta.url,' : ''
      },\n      env: ${JSON.stringify(generatorEnv).replace(/","/g, '", "')}${
        Object.keys(generateOpts).length ? ',\\n      ' + JSON.stringify(generateOpts, null, 2).slice(4, -2).replace(/\\n/g, `\\n    `) : ''
      }
    });
${isImportMapTarget ? `
    await Promise.all(process.env.DEPS.split(',')${CHOMP_EJECT ? '' : '.filter(dep => dep !== "node_modules/@jspm/generator" && dep !== "node_modules/mkdirp")'}.map(dep => generator.traceInstall('./' + dep)));
    await writeFile(process.env.TARGET, JSON.stringify(generator.getMap(), null, 2));`
: `
    const htmlSource = await readFile(process.env.DEP, 'utf-8');
    mkdirp.sync(dirname(process.env.TARGET));
    await writeFile(process.env.TARGET, await generator.htmlGenerate(htmlSource, {
      htmlUrl: pathToFileURL(process.env.TARGET)${noHtmlOpts ? '' : ',      ' + JSON.stringify({ preload, integrity, whitespace, esModuleShims })}
    }));`}
`
  }, ...CHOMP_EJECT ? [] : [{
    template: 'npm',
    templateOptions: {
      autoInstall,
      packages: ['@jspm/generator', 'mkdirp'],
      dev: true
    }
  }]];
}
"""
[[template]]
name = "npm"
# TODO: validate = "(templateOptions) => true / false / 'error message'"
# TODO: max-jobs = 1
definition = """({ name, deps, env, templateOptions: { packages, dev, packageManager = 'npm', autoInstall } }, { CHOMP_EJECT }) => CHOMP_EJECT ? [] : autoInstall ? [{
  name,
  deps: [...deps, ...packages.map(pkg => {
    const versionIndex = pkg.indexOf('@', 1);
    return `node_modules/${versionIndex === -1 ? pkg : pkg.slice(0, versionIndex)}`;
  })],
  serial: true
}, ...packages.map(pkg => {
  const versionIndex = pkg.indexOf('@', 1);
  return {
    target: `node_modules/${versionIndex === -1 ? pkg : pkg.slice(0, versionIndex)}`,
    invalidation: 'not-found',
    deps: ['npm:init'],
    env,
    run: `${packageManager} install ${packages.join(' ')}${dev ? ' -D' : ''}`
  };
}), {
  name: 'npm:init',
  target: 'package.json',
  invalidation: 'not-found',
  env,
  run: `${packageManager} init -y`
}] : [{
  name,
  env,
  invalidation: 'not-found',
  targets: packages.map(pkg => {
    const versionIndex = pkg.indexOf('@', 1);
    return `node_modules/${versionIndex === -1 ? pkg : pkg.slice(0, versionIndex)}`;
  }),
  run: `echo "\n\\x1b[93mChomp\\x1b[0m: Some packages are missing. Please run \\x1b[1m${packageManager} install ${packages.join(' ')}${dev ? ' -D' : ''}\\x1b[0m\n"`
}];
"""
reduction = """(execs) => {
  let init;
  const initIndex = execs.findIndex(({ env }) => env.TARGET === 'package.json');
  const initReplaces = [];
  if (initIndex !== -1) {
    const initExec = execs[initIndex];
    init = { run: initExec.run, engine: initExec.engine, env: initExec.env, replaces: initReplaces };
  }

  let install, devInstall, verify, devVerify;
  for (let i = 0; i < execs.length; i++) {
    const exec = execs[i];
    if (exec.env.TARGET === 'npm:init') {
      initReplaces.push(i);
    }
    else {
      const { engine, run, env } = exec;
      let { INSTALL_PKG, INSTALL_DEV } = env;

      const isInstall = !run.startsWith('echo');
      const isDev = !!INSTALL_DEV;

      if (isInstall && !run.startsWith(initPackageManager))
        return "Different package managers in use, please ensure to use one at a time!";

      const existing = isInstall && !isDev ? install : isInstall && isDev ? devInstall : !isDev ? verify : devVerify;
      if (existing) {
        existing.env.INSTALL_PKG += " " + INSTALL_PKG;
        existing.replaces.push(i);
      }
      else {
        const replacement = { engine, run, env, replaces: [i] };
        if (isInstall && !isDev)
          install = replacement;
        else if (isInstall && isDev)
          devInstall = replacement;
        else if (!isDev)
          verify = replacement;
        else
          devVerify = replacement;
      }
    }
  }
  return [...init ? [init] : [], install ? [install] : [], ...devInstall ? [devInstall] : [], ...verify ? [verify] : [], ...devVerify ? [devVerify] : []];
}
"""
[[template]]
name = "prettier"
definition = """({ name, targets, deps, env, templateOptions: { files = '.', check = false, write = true, config = null, noErrorOnUnmatchedPattern = false, autoInstall } }, { CHOMP_EJECT }) => [{
  name,
  targets,
  deps: [...deps, ...CHOMP_EJECT ? []: ['node_modules/prettier']],
  invalidation: 'always',
  env,
  run: `prettier ${files} ${
      check ? ' --check' : ''
    }${
      write ? ' --write' : ''
    }${
      config ? ` --config ${config}` : ''
    }${
      noErrorOnUnmatchedPattern ? ' --no-error-on-unmatched-pattern' : ''
    }`
}, ...CHOMP_EJECT ? [] : [{
  template: 'npm',
  templateOptions: {
    autoInstall,
    packages: ['prettier'],
    dev: true
  }
}]]
"""
[[template]]
name = "svelte"
definition = """({ name, targets, deps, env, templateOptions: { svelteConfig = null, autoInstall } }, { CHOMP_EJECT }) => [{
  name,
  targets,
  deps: [...deps, ...CHOMP_EJECT ? [] : ['node_modules/svelte', 'node_modules/mkdirp']],
  env,
  engine: 'node',
  run: `    import { readFile, writeFile } from 'fs/promises';
    import { compile } from 'svelte/compiler';
    import mkdirp from 'mkdirp';
    import { dirname } from 'path';

    let config;
    ${svelteConfig ? `
      config = await import(${svelteConfig === true ? '"./svelte.config.js"' : svelteConfig});
    ` : `
      config = {
        css: false
      };
    `}
    config.filename = process.env.DEP;

    const source = await readFile(process.env.DEP, 'utf-8');
    const result = compile(source, config);

    mkdirp.sync(dirname(process.env.TARGET));
    const cssFile = process.env.TARGET.replace(/\\.js$/, ".css");
    await Promise.all[
      writeFile(process.env.TARGET, result.js.code),
      writeFile(process.env.TARGET + ".map", JSON.stringify(result.js.map)),
      writeFile(cssFile, result.css.code),
      writeFile(cssFile + ".map", JSON.stringify(result.css.map))
    ];
  `
}, ...CHOMP_EJECT ? [] : [{
  template: 'npm',
  templateOptions: {
    autoInstall,
    packages: ['svelte@3', 'mkdirp'],
    dev: true
  }
}]]
"""
[[template]]
name = "swc"
definition = """({ name, targets, deps, env, templateOptions: { configFile = null, noSwcRc = false, sourceMaps = true, config = {}, autoInstall } }, { PATH, CHOMP_EJECT }) => {
  const isWin = PATH.match(/\\\\|\\//)[0] !== '/';
  const defaultConfig = {
    jsc: {
      parser: {
        syntax: 'typescript',
        importAssertions: true,
        topLevelAwait: true,
        importMeta: true,
        privateMethod: true,
        dynamicImport: true
      }/*,
      experimental: {
        keepImportAssertions: true
      }*/ // TODO: reenable when supported
    }
  };
  function setDefaultConfig (config, defaultConfig, base = '') {
    for (const prop of Object.keys(defaultConfig)) {
      const val = defaultConfig[prop];
      if (typeof val === 'object') {
        setDefaultConfig(config, defaultConfig[prop], base + prop + '.');
      }
      else if (!((base + prop) in config)) {
        config[base + prop] = defaultConfig[prop];
      }
    }
  }
  if (noSwcRc) {
    setDefaultConfig(config, defaultConfig);
  }
  return [{
    name,
    targets,
    deps: [...deps, ...noSwcRc || CHOMP_EJECT ? [] : ['.swcrc'], ...CHOMP_EJECT ? [] : ['node_modules/@swc/core', 'node_modules/@swc/cli']],
    env,
    run: `node ./node_modules/@swc/cli/bin/swc.js $DEP -o $TARGET${
        noSwcRc ? ' --no-swcrc' : ''
      }${
        configFile ? ` --config-file=${configFile}` : ''
      }${
        sourceMaps ? ' --source-maps' : ''
      }${
        Object.keys(config).length ? ' ' + Object.keys(config).map(key => `-C ${key}=${config[key]}`).join(' ') : ''
      }`
  }, ...CHOMP_EJECT ? [] : [{
    target: '.swcrc',
    invalidation: 'not-found',
    run: `
      echo '\n\\x1b[93mChomp\\x1b[0m: Creating \\x1b[1m.swcrc\\x1b[0m (set \\x1b[1m"no-swc-rc = true"\\x1b[0m SWC template option to skip)\n'
      ${isWin // SWC does not like a BOM... Powershell hacks...
        ? `$encoder = new-object System.Text.UTF8Encoding ; Set-Content -Value $encoder.Getbytes('${JSON.stringify(defaultConfig, null, 2)}') -Encoding Byte -Path $TARGET`
        : `echo '${JSON.stringify(defaultConfig)}' > $TARGET`
      }
    `
  }, {
    template: 'npm',
    templateOptions: {
      autoInstall,
      packages: ['@swc/core@1', '@swc/cli@0.1'],
      dev: true
    }
  }]];
}
"""
